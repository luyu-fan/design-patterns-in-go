# 测试

`go test`是go内部环境提供的集成单元测试、性能测试以及案例测试的工具，其源码位于`cmd/test`之下。基础工具之一。

test工具会识别各个包中的以`_test.go`为后缀的源码文件，并且会忽略那些以`_test`或者`.test`直接命名的文件，然后将各个测试
文件编译成一个个独立的二进制测试包，然后连接到主测试程序上。不过在编译时，`testdata`文件夹会被忽略，仅仅保留那些测试所
必须的数据，因此在测试时可以将所有的测试数据集中放在此文件夹中。

所有的测试输出都会被汇总并打印到go命令行的标注输出流。输出中主要包含:
`ok` -> 测试通过。
`FAIL` -> 失败。
以及对应的测试耗费时间。

## 前置检测

在编译生成二进制包之前，`go test`会先使用`go vet`对所涉及到的包和它对应的测试源码进行检测，如果有相关问题被报出，则不会进行
后续的测试步骤。如果不想进行检测则需要使用标志参数`-vet=off`来关闭。

## 测试模式

### 局部目录模式

仅测试当前目录环境下的测试用例，不提供包参数。此模式下不会对测试结果进行缓存。使用的命令如下:

`go test`或`go test -v`.

### 包列表模式

测试那些在命令后面用参数显式指明的包，此时会编译每一个指明包中的测试文件，并且以包为单位进行测试结果输出，当某一个包里面有未通过的测试用例时才会
进行详细输出，但如果指明了`-v`或者`-bench`参数，则所有的测试用例都会被打印。

在测试使用可缓存的标记情况下(`-cpu, -list, -parallel, -run, -short, -v`), 此模式下的测试通过的包其结果会被缓存，
当再次重复测试且当前包没有变化时则直接获取通过后的测试结果即可，但会加上cached标记。如果使用的不在上述集合中的标记则不会被
缓存，例如最简单的方式便是在后面加上一个`-count=1`来破坏可缓存性。

## 额外参数

`go test`自身所特有的命令标志有:

> `-args`: 为所有的测试包传递参数，不可被打断和更改。
> `-c`: 将测试包编译为二进制文件但不执行，通常可以和-o配合使用指定输出位置。
> `-exec xprog`: 使用xprog来运行二进制包。
> `-i`: 安装测试所需要的依赖，但不执行，但已经被废弃了。
> `-json`: 将测试输出转为json兼容的文件。
> `-o`: 输出。

## 测试标志

`go test`后面可以跟控制测试行为本身的参数以及测试后面需要传递给二进制包的参数。有一些标志可以和性能工具`pprof`搭配使用。所有的标志都可以加上`test.`
前缀，例如`-test.v`，在`-c`标志使用时则是必要的。

### 常见标志

> `-bench regexp`: 性能测试。如果没有正则表达式提供则不会运行，如果想要测试所有则需要提供-bench .或者-bench=.。正则表达式中可以使用/来分割
两个部分以达到形成层级关系，而且嵌套外层会运行b.N=1次，内层则会依据指定的次数执行。
> `-benchtime t`: 给定指定的测试时间，在这个时间内执行足够多的测试迭代，使用时间英文字符串表示，例如1h30s，默认时间为1s。而如果使用Nx形式则是 
从运行次数角度指定，即执行N次测试。
> `-count n`: 表示整体的测试需要运行几次，默认为1.
> `-cover`: 启动覆盖测试分析，覆盖率计算工作会在编译前进行。
> `-covermode {set|count|atomic}`: 覆盖分析的模式，显然需要开启-cover，当没有开启-race分析的时候是set模式，否则则是atomic模式。其中:
set: 语句是否执行。 count: 语句执行了多少次。 atomic: 语句原子执行了多少次，执行成本相对较高。
> `-coverpkg pattern1,pattern2`: 在匹配上模式的包内测试用例上执行覆盖分析，没指定情况下所有的测试都会进行覆盖分析。
> `-cpu n`: 指定测试时能够使用的最多处理器数目，通常默认情况下就是系统的cpu核心数GOMAXPROCS。
> `-failfast`: 第一个测试失败之后不要启动后续新的测试。
> `-list regexp`: 仅仅罗列那些成功匹配了表达式的测试用例，但不执行，并且仅仅匹配最高级的用例，子用例并不考虑。
> `-parallel n`: 设置单个测试二进制内进行测试时能够同时执行的测试函数的数目(和test工具并发测试多个包进行区分)，通常和t.Parallel有关，默认也设置为GOMAXPROCS.
> `-run regexp`: 仅仅测试那些满足表达式的用例，同样通过/分隔层级，只要是匹配上的都会执行，纵使没有子用例的情况。
> `-short`: 通知比较长时间的测试用例缩短测试时间。默认处于关闭状态。
> `-timeout d`:  如果某个测试用例时间过长则报panic，默认为10分钟，当设置为0时表示关闭超时。
> `-v`: 打印出所有的测试用例的执行情况，无论失败或成功。
> `-vet list`: 配置在测试之前的检测，对逗号分隔的包列表进行验证，当为空时go vet会智能地对某些值得验证的包进行验证，当为off时则关闭。

### 性能分析相关的标志

> `-benchmem`: 打印在性能测试时的内存耗费。
> `-blockprofile block.out`: 将Goroutine阻塞信息写入到指定的文件中。
> `-blockprofilerate n`: 控制阻塞信息输出细节，本质上是调用runtime.SetBlockProfileRate，profiler在每n纳秒内对程序内的阻塞耗费进行采样,
如果开启了blockprofile, 默认情况下所有的阻塞事件都会被记录，即此时n=1。更详细的情况: `go doc runtime.SetBlockProfileRate`。
> `-coverprofile cover.out`: 同上，输出覆盖率信息。
> `-cpuprofile cpu.out`: 同上，输出CPU信息。
> `-memprofile mem.out`: 同上，输出内存分配信息。
> `-memprofilerate n`: 同blockprofilerate,输出更详细的内存分配情况。
> `-mutexprofile mutex.out`: 同上，输出互斥锁使用信息。
> `-mutexprofilerate n`: 同上，对1/n的持有互斥锁的Goroutines跟踪进行采样。
> `-outputdir dir`: 指定输出文件放置的文件夹。
> `-trace trace.out`: 将跟踪情况写入指定文件。

## 其它

1. go test会重写或重组织已识别的命令。
2. 当进行profile分析输出的时候，对应的标志会使得test产生对应的pkg.test。
3. 如果命令行中出现了包列表，那么它必须放在test命令识别的任何标志之前，但对于-v则任何一侧均可。
4. 在包列表模式下，如果不想使用缓存，则只要使用任何一个不在cacheable集合中的标志即可。

## 常见问题



